## Архитектура

### Структура проекта

```
osctl/
├── cmd/
│   └── main.go                    # Точка входа приложения
├── commands/                      # Команды CLI
│   ├── root.go                   # Общие флаги и список команд
│   ├── snapshots.go               # Создание снапшотов
│   ├── indicesdelete.go          # Удаление индексов согласно конфигурации
│   ├── snapshotsdelete.go         # Удаление снапшотов согласно конфигурации
│   ├── retention.go              # Удаление самых старых и больших индексов
│   ├── sharding.go               # Автоматическое шардирование (не реализовано)
│   ├── indexpatterns.go         # Kibana index patterns (не реализовано)
│   ├── datasource.go             # Kibana data sources (не реализовано)
│   ├── dereplicator.go           # Уменьшение реплик до 0
│   ├── snapshotschecker.go        # Проверка snapshots
│   ├── danglingchecker.go        # Проверка dangling индексов
│   ├── coldstorage.go            # Миграция в cold storage
│   └── extracteddelete.go        # Удаление extracted индексов
├── pkg/
│   ├── config/                   # Конфигурация
│   │   ├── config.go            # Основная конфигурация
│   │   └── osctlindicesconfig.go # Конфигурация индексов
│   ├── opensearch/              # OpenSearch API клиент
│   │   └── client.go
│   ├── kibana/                  # Kibana API клиент
│   │   └── client.go
│   ├── alerts/                  # Madison алерты
│   │   └── to_madison.go
│   ├── logging/                 # Логирование
│   │   └── logger.go
│   └── utils/                   # Утилиты
│       ├── date.go              # Действия с датами
│       ├── indices.go           # Работа с индексами
│       └── snapshots.go        # Работа со снапшотами
├── config-example/                # Примеры конфигураций, job и деплойментов
├── Dockerfile
├── go.mod
├── go.sum
├── config.yaml                      # Единый конфиг
└── README.md
```

## Алгоритмы для каждого флага

### 1. **snapshots** - Создание снапшотов индексов

**Алгоритм:**
1. **Загрузка конфигурации**: Получаем `osctl-indices-config` через `--osctl-indices-config`
2. **Разделение конфигураций**: Разделяем конфигурации на системные (`system: true`) и обычные (`system: false`)
3. **Получение индексов**:
   - **Системные индексы**: `GET /_cat/indices/.*` для индексов, начинающихся с точки (только если есть конфигурации с `system: true`)
   - **Обычные индексы**: `GET /_cat/indices/*{yesterday}*` для индексов за вчера (только если есть конфигурации с `system: false`)
4. **Группировка индексов**:
   - Для каждого индекса находим соответствующий конфиг через `FindMatchingIndexConfig`
   - Пропускаем индексы с флагом `manual_snapshot: true`
   - Группируем индексы по паттернам через `GroupIndicesForSnapshots`
   - Создаем группы: prefix-based и regex-based снапшоты
5. **Dry run режим**: Показываем план создания снапшотов
6. **Создание снапшотов**:
   - Проверяем существующие снапшоты через `GET /_snapshot/{repo}/*{today}*`
   - Для каждой группы проверяем/удаляем ошибочный снапшот через `CheckAndCleanSnapshot`
   - Создаем снапшот через `CreateSnapshotWithRetry` с retry логикой и ожиданием выпоолнения тасок
7. **Unknown индексы**: Если включено в конфиге и `manual_snapshot: false`, создаем снапшот "unknown-{date}"

**Конфигурация:**
- Использует `--osctl-indices-config` для централизованной конфигурации
- Поддерживает prefix и regex паттерны
- Разделяет обработку системных и обычных индексов
- Пропускает индексы с флагом `manual_snapshot: true`

### 2. **snapshotmanual** - Ручное создание снапшотов

**Алгоритм:**
1. **Загрузка параметров**: Получаем параметры индекса через CLI флаги
2. **Валидация**: Проверяем обязательные параметры (value, name для regex)
3. **Получение индексов**: 
   - **Системные индексы** (`--system`): `GET /_cat/indices/.*` для индексов, начинающихся с точки
   - **Обычные индексы** (без `--system`): `GET /_cat/indices/*{yesterday}*` для индексов за вчера
4. **Поиск соответствующих индексов**: находим индексы соответствующие паттерну через `MatchesIndex` с учетом флага `system`
5. **Ожидание завершения**: Ждем завершения активных снапшотов и тасок
6. **Создание снапшота**:
   - Проверяем существующие снапшоты через `GET /_snapshot/{repo}/*{today}*`
   - Проверяем/удаляем ошибочный снапшот через `CheckAndCleanSnapshot`
   - Создаем снапшот через `CreateSnapshotWithRetry` с retry логикой
7. **Dry run режим**: Показываем план создания снапшота

**Конфигурация:**
- Использует CLI флаги для параметров одного паттерна индексов
- Поддерживает prefix и regex паттерны
- Учитывает флаг `--system` для системных индексов
- Не обрабатывает unknown индексы
- Не использует `--osctl-indices-config`

### 3. **snapshotsdelete** - Удаление снапшотов

**Алгоритм:**
1. **Загрузка конфигурации**: Получаем `osctl-indices-config` и S3 конфигурацию
2. **Получение снапшотов**: `GET /_snapshot/{repo}/*` для всех снапшотов
3. **Фильтрация снапшотов**:
   - Для каждого снапшота находим соответствующий конфиг через `FindMatchingSnapshotConfig`
   - Если конфиг найден и `snapshot: true`:
     - Используем `snapshot_count_s3` или `unit_count.all` как количество дней
     - Проверяем возраст через `IsOlderThanCutoff`
4. **Unknown снапшоты**: Фильтруем через `FilterUnknownSnapshots` и применяем `unit_count.unknown`
5. Снапшоты без даты в названии попадют под политику удаления Unknown, по дате создания снапшота.
5. **Удаление**: Через `DeleteSnapshotsBatch` с dry run поддержкой

Никогда не трогаем снапшоты без даты в нужном формате страше чем Unknown политика ( но выводим их в лог)

### 4. **indicesdelete** - Удаление индексов

**Алгоритм:**
1. **Загрузка конфигурации**: Получаем `osctl-indices-config`
2. **Получение индексов**: `GET /_cat/indices/*` для всех индексов
3. **Фильтрация индексов**:
   - Для каждого индекса находим соответствующий конфиг через `FindMatchingIndexConfig`
   - Если конфиг найден, проверяем возраст через `IsOlderThanCutoff` с `days_count`
4. **Unknown индексы**: Фильтруем через `FilterUnknownIndices` и применяем `unknown.days_count`
5. **Удаление**: Через `DeleteIndicesBatch` с dry run поддержкой

Никогда не удаляем .* - системные
Никогда не трогаем индексы без даты в нужном формате страше чем Unknown политика ( но выводим их в лог)

### 5. **retention** - Удаление индексов по утилизации диска

**Алгоритм:**
1. **Расчёт утилизации**: Получаем `GET /_cat/allocation`, считаем среднюю утилизацию
2. **Если утилизация > порога**:
   - Получаем кандидатов через `GET /_cat/indices` (исключая сегодня, вчера, `extracted_*`)
   - Сортируем по размеру (убывание)
   - Для каждого индекса:
     - Проверяем snapshots в репо через `GET /_snapshot/{snap_repo}/*`
     - Если есть валидный снапшот - удаляем индекс через `DELETE /{index}`
     - Повторяем пока утилизация не упадёт ниже порога

### 6. **dereplicator** - Уменьшение реплик старых индексов

**Алгоритм:**
1. **Получение индексов**: `GET /_cat/indices/*` для всех индексов
2. **Фильтрация по возрасту**: индексы старше `--days-count` дней
3. **Исключения**:
   - Индексы за последние N дней
   - Системные индексы (начинающиеся с `.`)
   - Индексы с 0 репликами
4. **Проверка snapshots** (если `--use-snapshot`):
   - Получаем snapshots через `GET /_snapshot/{snap_repo}/*`
   - Проверяем SUCCESS статус для каждого индекса
5. **Установка 0 реплик**: через `PUT /{index}/_settings`

### 7. **coldstorage** - Миграция в cold storage

**Алгоритм:**
1. **Получение индексов**: `GET /_cat/indices/*` для всех индексов
2. **Фильтрация по возрасту**: индексы старше `--hot-count` дней
3. **Перемещение в cold**: через `PUT /{index}/_settings` с allocation settings:
   ```json
   {
     "index": {
       "routing.allocation.require.temp": "{cold-attribute}",
       "number_of_replicas": 0
     }
   }
   ```
### 8. **snapshotschecker** - Проверка наличия снапшотов

**Алгоритм:**
1. **Загрузка конфигурации**: Получаем `osctl-indices-config`
2. **Получение индексов**: за позавчерашний день через `GET /_cat/indices/*{dayBeforeYesterday}*`
3. **Определение ожидаемых индексов**:
   - Для каждого индекса проверяем соответствие конфигурации
   - Если `snapshot: true` в конфиге - добавляем в ожидаемые
   - Если включен `unknown.snapshot` - добавляем unknown индексы
4. **Проверка снапшотов**: за вчерашний день через `GET /_snapshot/{repo}/*{yesterday}*`
5. **Поиск отсутствующих**: через `HasValidSnapshot`
6. **Алерт в Madison**: если найдены отсутствующие снапшоты

### 9. **danglingchecker** - Проверка dangling индексов

**Алгоритм:**
1. **Запрос dangling**: `GET /_dangling?pretty`
2. **Если найдены**: отправляем алерт в Madison через `SendMadisonDanglingAlert`

### 10. **extracteddelete** - Удаление extracted индексов

**Алгоритм:**
1. **Получение индексов**: `GET /_cat/indices/extracted*` для всех extracted индексов
2. **Фильтрация по возрасту**: старше `--days` дней по формату даты
3. **Удаление**: через `DELETE /{index}` для каждого подходящего индекса

### 3. **sharding** - Автоматическое шардирование

**Алгоритм:**

1. **Получение всех индексов**: `GET /_cat/indices?bytes=b&s=ss` - делается чтобы учитывать не размер сегодняешнего а максимальный размер вообще
2. **Получение индексов за сегодня**: `GET /_cat/indices/-.*,*-{today}*?bytes=b&s=ss`
3. **Для каждого индекса за сегодня**:
   - Генерируем pattern: `{index_name_without_date}*`
   - Ищем максимальный размер среди индексов с pattern `{index_name_without_date}` - если больше указанного размера - это триггер для шардинга
   - Вычисляем приоритет: `количество_дефисов * 1000` (infra- отличается от infra-elklogs- приоритетами)
   - Создаём template: `{index_name_without_date}-sharding`
4. **Расчёт shards**: `shards_needed = max_size / 25GiB + 1`, но с ограничением по числу нод
5. **Создание template** с рассчитанным `priority` и настройками:
   - `number_of_shards`: рассчитанное количество
   - `number_of_replicas`: 1
   - `mapping.total_fields.limit`: 2000
   - `routing.allocation.require.temp`: "hot" (если включен cold cluster)
   - `query.default_field`: ["message","text","log","original_message"]
6. Если шаблон уже есть - **меняем ТОЛЬКО number_of_shards**

- 25GiB задаем параметром, с проверкой что он не больше 50Gib
- nodes-count = datanodes ( берем из кластера! - все ноды с типом data, не мастер и не колд)
- индексы с . не трогаем

### 4. **indexpatterns** - Управление Kibana index patterns

**Алгоритм (multitenancy):**
1. **Для каждого тенанта**:
   - Проверяем `.kibana*_tenant` через `GET /_cat/aliases/.kibana*_{tenant}`
   - Получаем существующие patterns через `GET /{tenant_index}/_search?q=type:index-pattern`
   - Создаём недостающие через `POST /{tenant_index}/_doc/index-pattern:{uuid}`

**Алгоритм (без multitenancy):**
   - Построение паттернов из сегодняшних индексов по регулярке
   - Сравнение с существующими в `.kibana`
   - Создание недостающих паттернов
   - Дополнительно создаём `extracted_*` с reference на data-source

- extracted_* по соображением безопасности не создается в режиме multitenancy
- regex нужен только в режиме Без multitenancy для исключения дерьма

### 5. **datasource** - Создание Kibana data sources

**Алгоритм:**
1. **Проверка существования**: через `GET /api/saved_objects/_find?type=data-source`
2. **Создание**: через `POST /api/saved_objects/data-source` с basic auth
3. **Multidomain режим**:
   - Собираем CA из env и kube секретов
   - Сравниваем с `multi-certs` секретом из REMOTE_CRT
   - При изменении: обновляем секрет и рестартуем kibana

### Приоритет конфигурации

1. **CLI флаги** (высший приоритет)
2. **Переменные окружения**
3. **Файлы конфигурации**
4. **Значения по умолчанию** (низший приоритет)
